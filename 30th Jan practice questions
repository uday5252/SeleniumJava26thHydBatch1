

Maximum Occurring Character

---

 1ï¸âƒ£ What is given?

You are given one string:

 Contains only:

   lowercase letters (`aâ€“z`)
   uppercase letters (`Aâ€“Z`)
   digits (`0â€“9`)
 Case matters

   `'a'` and `'A'` are different
 Length is between 10 and 10â´

Example:

```
"abbbaacc"
```

---

 2ï¸âƒ£ What do you need to find?

ğŸ‘‰ Find the character that appears the MOST times in the string.

---

 3ï¸âƒ£ What if two or more characters appear the same number of times?

ğŸ‘‰ Return the character that appears FIRST in the string

âš ï¸ This rule is very important.

---

 4ï¸âƒ£ Example explained (from question)

 Input

```
text = "abbbaacc"
```

 Count characters

```
a â†’ 3 times
b â†’ 3 times
c â†’ 2 times
```

There is a tie between `'a'` and `'b'`.

 Which comes first in the string?

```
"abbbaacc"
 â†‘
 a appears before b
```

âœ… Answer = 'a'

---

 5ï¸âƒ£ Sample Case 0 (given)

 Input

```
"helloworld"
```

 Count

```
h â†’ 1
e â†’ 1
l â†’ 3
o â†’ 2
w â†’ 1
r â†’ 1
d â†’ 1
```

ğŸ‘‰ `'l'` appears the most (3 times)

âœ… Answer = 'l'

---

 6ï¸âƒ£ Sample Case 1 (given)

 Input

```
"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
```

Each character appears exactly twice.

ğŸ‘‰ All tied
ğŸ‘‰ Pick the one that appears first

```
a b c d ...
â†‘
```

âœ… Answer = 'a'

---

 7ï¸âƒ£ Extra simple test cases

 Test Case 1

```
Input: "AAaa11"
Counts:
A â†’ 2
a â†’ 2
1 â†’ 2

First character = 'A'
Answer = 'A'
```

---

 Test Case 2

```
Input: "999888777"
Answer = '9'
```

---

 One-line meaning (Question 14)

> Find the most frequent character.
> If there is a tie, return the one that appears earliest in the string.

---

---

 ğŸ”¹ QUESTION 15.1: Maximum Score

This one is a greedy + priority type problem, but letâ€™s just understand it first.

---

 1ï¸âƒ£ What is given?

 An integer array `arr` of size `n`
 An integer `k` â†’ number of operations
 Start with:

```
score = 0
```

---

 2ï¸âƒ£ What happens in ONE operation?

You can choose ANY ONE element from the array.

Then:

1. Add its value to `score`
2. Replace that element with:

```
ceil(value / 3)
```

ğŸ‘‰ Ceiling means round UP

---

 ğŸ”¹ Ceiling examples

```
ceil(10 / 3) = 4
ceil(9 / 3)  = 3
ceil(1 / 3)  = 1
```

---

 3ï¸âƒ£ Goal

ğŸ‘‰ Perform exactly k operations
ğŸ‘‰ Get the MAXIMUM possible score

You are free to choose any element in every operation, even the same one again.

---

 4ï¸âƒ£ Key idea (important intuition)

To get maximum score:

 Always pick the largest number available
 Because:

   It adds more to the score
   After replacement, it becomes smaller anyway

---

 5ï¸âƒ£ Main example explained (from question)

 Input

```
arr = [20, 4, 3, 1, 9]
k = 4
```

---

 Operation 1

Pick 20

```
score = 20
20 â†’ ceil(20/3) = 7
arr = [7, 4, 3, 1, 9]
```

---

 Operation 2

Pick 7

```
score = 27
7 â†’ ceil(7/3) = 3
arr = [3, 4, 3, 1, 9]
```

---

 Operation 3

Pick 4

```
score = 31
4 â†’ ceil(4/3) = 2
arr = [3, 2, 3, 1, 9]
```

---

 Operation 4

Pick 9

```
score = 40
9 â†’ ceil(9/3) = 3
arr = [3, 4, 3, 1, 3]
```

âœ… Final Answer = 40

---

 6ï¸âƒ£ Sample Case 0 (given)

 Input

```
arr = [4, 5, 18, 1]
k = 3
```

 Best choices

1. Pick 5 â†’ score = 5 â†’ becomes 2
2. Pick 18 â†’ score = 23 â†’ becomes 6
3. Pick 6 â†’ score = 29 â†’ becomes 2

âœ… Answer = 29

---

 7ï¸âƒ£ Sample Case 1 (given)

 Input

```
arr = [1, 1, 1]
k = 2
```

Each time:

```
1 â†’ ceil(1/3) = 1
```

So values never change.

Score:

```
1 + 1 = 2
```

âœ… Answer = 2

---

 8ï¸âƒ£ Extra test cases

 Test Case 1

```
arr = [10]
k = 3

Ops:
10 â†’ 4 â†’ 2
Score = 10 + 4 + 2 = 16
```

---

 Test Case 2

```
arr = [5, 5]
k = 2

Pick 5 twice:
Score = 5 + 5 = 10
```

---


 ğŸ§ Memory Test

---

 1ï¸âƒ£ What is given?

 `n` children standing in a row
 Children are numbered by position:

```
0, 1, 2, ..., n-1
```

 The teacher conducts `m` rounds
 In each round, the teacher chooses one position `pos[i]`

---

 2ï¸âƒ£ What happens in ONE round?

Suppose the teacher selects position `p`.

 Rules for numbering:

 Child at position `p` gets 0
 Children to the right:

   Each child gets 1 more than the child to their left
 Children to the left:

   Each child gets 1 more than the child to their right

ğŸ“Œ This means:

> Every child gets a number equal to
> distance from position `p`

---

 ğŸ”¹ Formula (just for understanding)

For child at position `i`:

```
number = |i - p|
```

---

 3ï¸âƒ£ Example to understand ONE round

 Example

```
n = 6
p = 3
```

Positions:

```
0  1  2  3  4  5
```

Numbers assigned:

```
3  2  1  0  1  2
```

Because:

 Distance from 3 is increasing as you move away

---

 4ï¸âƒ£ What happens after ALL rounds?

Each child will have received m different numbers
(one number in each round)

ğŸ‘‰ The teacher asks each child:

> What is the MAXIMUM number you ever received?

Your task:

 For every child (0 to nâˆ’1)
 Find the maximum value assigned to them across all rounds

---

 5ï¸âƒ£ Main Example (from question)

 Input

```
n = 5
m = 4
pos = [3, 0, 1, 4]
```

---

 Round 1 (pos = 3)

```
[3, 2, 1, 0, 1]
```

---

 Round 2 (pos = 0)

```
[0, 1, 2, 3, 4]
```

---

 Round 3 (pos = 1)

```
[1, 0, 1, 2, 3]
```

---

 Round 4 (pos = 4)

```
[4, 3, 2, 1, 0]
```

---

 Now take MAX for each child

| Child index | Values across rounds | Maximum |
| ----------- | -------------------- | ------- |
| 0           | 3, 0, 1, 4           | 4   |
| 1           | 2, 1, 0, 3           | 3   |
| 2           | 1, 2, 1, 2           | 2   |
| 3           | 0, 3, 2, 1           | 3   |
| 4           | 1, 4, 3, 0           | 4   |

âœ… Answer

```
[4, 3, 2, 3, 4]
```

---

 6ï¸âƒ£ Sample Case 0 (given)

 Input

```
n = 5
pos = [2, 0, 3]
```

---

 Round 1 (pos = 2)

```
[2, 1, 0, 1, 2]
```

 Round 2 (pos = 0)

```
[0, 1, 2, 3, 4]
```

 Round 3 (pos = 3)

```
[3, 2, 1, 0, 1]
```

---

 Take maximum for each child

| Child | Max                |
| ----- | ------------------ |
| 0     | max(2,0,3) = 3 |
| 1     | max(1,1,2) = 2 |
| 2     | max(0,2,1) = 2 |
| 3     | max(1,3,0) = 3 |
| 4     | max(2,4,1) = 4 |

âœ… Output

```
3
2
2
3
4
```

---

 7ï¸âƒ£ Sample Case 1 (given)

 Input

```
n = 4
pos = [0, 1, 2, 3]
```

---

 Round assignments

```
pos = 0 â†’ [0, 1, 2, 3]
pos = 1 â†’ [1, 0, 1, 2]
pos = 2 â†’ [2, 1, 0, 1]
pos = 3 â†’ [3, 2, 1, 0]
```

---

 Maximum per child

| Child | Max |
| ----- | --- |
| 0     | 3   |
| 1     | 2   |
| 2     | 2   |
| 3     | 3   |

âœ… Output

```
[3, 2, 2, 3]
```


 ğŸ”¹Optimal Selection

---

 1ï¸âƒ£ What is given?

You are given:

 An integer array `arr` of length `n`

Example:

```
[1, 1, 3, 2]
```

---

 2ï¸âƒ£ What operation are you allowed to do?

You are allowed to perform AT MOST ONE operation.

That operation has two parts:

 âœ… Part A: Choose some elements

 You may choose any subset of indices
 Important rule:
  ğŸ‘‰ No two chosen elements can be adjacent

So these are valid:

```
[0, 2, 4]
[1, 3]
[3]
```

These are NOT valid:

```
[1, 2]   âŒ adjacent
[0, 1]   âŒ adjacent
```

---

 âœ… Part B: Choose a number `x`

 `x` must be non-negative (`x â‰¥ 0`)
 Add `x` to all selected elements

ğŸ“Œ You must use the same `x` for every selected element.

---

 3ï¸âƒ£ What is the goal?

After doing at most one such operation:

ğŸ‘‰ The array must become non-decreasing

 What does non-decreasing mean?

```
arr[i] â‰¤ arr[i+1]   for all i
```

Valid:

```
[1, 2, 2, 5]
```

Invalid:

```
[3, 1, 4]
```

---

 4ï¸âƒ£ What do you need to return?

 Return the minimum non-negative value of `x`
 If it is impossible, return `-1`

---

 5ï¸âƒ£ Example given in the question

 Input

```
arr = [1, 1, 3, 2]
```

---

 Problem spot

```
3 > 2   âŒ (index 2 â†’ 3)
```

We must fix this using one operation only.

---

 Option 1

Select index `3` only
Add `x = 1`

```
[1, 1, 3, 3]   âœ…
```

Array is now non-decreasing.

---

 Option 2

Select indices `[1, 3]`
Add `x = 2`

```
[1, 3, 3, 4]   âœ…
```

---

 Minimum `x` among all valid options?

```
x = 1
```

âœ… Answer = 1

---

 6ï¸âƒ£ Sample Case 0 (given)

 Input

```
arr = [3, 1, 3, 2, 4]
```

---

 Check where array decreases

```
3 > 1   âŒ
3 > 2   âŒ
```

Indices causing problems:

 index 1
 index 3

---

 Can we select both?

Indices `[1, 3]`
They are not adjacent, so allowed âœ…

---

 How much increment needed?

```
1 + x â‰¥ 3  â†’ x â‰¥ 2
2 + x â‰¥ 3  â†’ x â‰¥ 1
```

So minimum `x = 2`

---

 After operation

```
[3, 3, 3, 4, 4]   âœ…
```

âœ… Answer = 2

---

 7ï¸âƒ£ Sample Case 1 (given)

 Input

```
arr = [4, 1, 3, 5, 6, 5]
```

---

 Where does it decrease?

```
4 > 1   âŒ (index 1)
6 > 5   âŒ (index 5)
```

Indices needing increase:

```
1 and 5
```

---

 Problem

To fix:

 index 1 needs to increase
 index 5 needs to increase

But:

 Fixing index 1 affects future comparisons
 Fixing index 5 does not fix earlier violations
 Some violations require adjacent elements to be increased together
 But adjacent selection is NOT allowed

ğŸ‘‰ No single `x` and valid subset can fix all problems

âŒ Impossible

âœ… Answer = -1

---

 8ï¸âƒ£ Important edge cases

 Case 1: Already sorted

```
arr = [1, 2, 3, 4]
```

No operation needed
Minimum `x = 0`

---

 Case 2: Single element

```
arr = [5]
```

Always non-decreasing
Answer = `0`

---

 Case 3: Adjacent violations

```
arr = [3, 2, 1]
```

Indices 1 and 2 both need fixing
But they are adjacent âŒ

Answer = `-1`

---
