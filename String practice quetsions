

 üìò QUESTION

You are given a binary string `target` (only `0` and `1`).

 Starting point:

 You start with a string of the same length
 All characters are `0`

Example:
If `target = "1011"`
You start with:

```
0000
```

---

 üîÅ ALLOWED OPERATION (VERY IMPORTANT)

You can do only one type of operation:

üëâ Choose an index `i`
üëâ Flip all characters from index `i` to the end

 Flip means:

 `0 ‚Üí 1`
 `1 ‚Üí 0`

---

 üéØ GOAL

Convert the initial all-zero string into the target string
using the minimum number of flips.

---

 üß† KEY IDEA (WHY THE ANSWER COMES LIKE THIS)

You don‚Äôt need to actually flip the string.

 Think like this:

 At the beginning, everything is `0`
 A flip changes the state of all future characters
 Once you flip, everything after that point becomes the opposite

So:

 Every time the target value changes, you must flip

---

 üß™ HOW ANSWER IS ARRIVED (STEP BY STEP)

 Example 1

```
target = "101"
```

Start:

```
000
```

 Step-by-step thinking:

| Position | Target | Current State | Do we need flip? | Why                        |
| -------- | ------ | ------------- | ---------------- | -------------------------- |
| 0        | 1      | 0             | YES              | We want 1 but have 0       |
| 1        | 0      | 1             | YES              | After flip, state became 1 |
| 2        | 1      | 0             | YES              | State again mismatches     |

 Total flips:

```
3
```

‚úÖ Answer = 3

---

 Example 2

```
target = "001011"
```

Start:

```
000000
```

| Position | Target | Current | Flip? | Reason          |
| -------- | ------ | ------- | ----- | --------------- |
| 0        | 0      | 0       | No    | Already correct |
| 1        | 0      | 0       | No    | Already correct |
| 2        | 1      | 0       | Yes   | Need 1          |
| 3        | 0      | 1       | Yes   | State changed   |
| 4        | 1      | 0       | Yes   | State changed   |
| 5        | 1      | 1       | No    | Already correct |

 Total flips:

```
3
```

‚úÖ Answer = 3

---



SOLUTION:

class Solution {
    public int minFlips(String target) {
        int flips = 0;

        for (char ch : target.toCharArray()) {
            // current state after all previous flips
            int currentState = flips & 1;   // 0 if even flips, 1 if odd flips

            // target bit at this position
            int targetBit = ch - '0';

            // if current state does not match target bit, flip is needed
            if (currentState != targetBit) {
                flips++;
            }
        }

        return flips;
    }
}

TRACING:

 üß™ Trace Example 1

 Input

```
target = "001011"
```

 Initial values

```
flips = 0
```

---

 Step-by-step Trace

| Step | Character | flips | currentState (`flips & 1`) | targetBit | Flip? | flips after |
| ---- | --------- | ----- | -------------------------- | --------- | ----- | ----------- |
| 1    | '0'       | 0     | 0                          | 0         | No    | 0           |
| 2    | '0'       | 0     | 0                          | 0         | No    | 0           |
| 3    | '1'       | 0     | 0                          | 1         | Yes   | 1           |
| 4    | '0'       | 1     | 1                          | 0         | Yes   | 2           |
| 5    | '1'       | 2     | 0                          | 1         | Yes   | 3           |
| 6    | '1'       | 3     | 1                          | 1         | No    | 3           |

---

 ‚úÖ Final Answer

```
3
```

---

 üß™ Trace Example 2

 Input

```
target = "101"
```

| Step | Character | flips | currentState | targetBit | Flip? | flips after |
| ---- | --------- | ----- | ------------ | --------- | ----- | ----------- |
| 1    | '1'       | 0     | 0            | 1         | Yes   | 1           |
| 2    | '0'       | 1     | 1            | 0         | Yes   | 2           |
| 3    | '1'       | 2     | 0            | 1         | Yes   | 3           |

---

 ‚úÖ Final Answer

```
3
```

---

=================================================================================
=================================================================================
=================================================================================
=================================================================================
=================================================================================
=================================================================================
=================================================================================
=================================================================================
class Solution { 
    public int minFlips(String target) { 
 
        int flips = 0; 
        char current = '0';  // initial all-zero state 
 
        for (int i = 0; i < target.length(); i++) { 
            if (target.charAt(i) != current) { 
                flips++; 
                current = target.charAt(i); // after flip, current state becomes target's bit 
            } 
        } 
 
        return flips; 
    }

target = "10111"
üîπ Initial State
Variable	Value
flips	0
current	'0'
i	0

| i | target[i] | current | target[i] != current? | Action  | flips after action | current after action |
| - | --------- | ------- | --------------------- | ------- | ------------------ | -------------------- |
| 0 | 1         | 0       | YES                   | flips++ | 1                  | 1                    |
| 1 | 0         | 1       | YES                   | flips++ | 2                  | 0                    |
| 2 | 1         | 0       | YES                   | flips++ | 3                  | 1                    |
| 3 | 1         | 1       | NO                    | none    | 3                  | 1                    |
| 4 | 1         | 1       | NO                    | none    | 3                  | 1                    |

====================================================================================================================
====================================================================================================================
====================================================================================================================
====================================================================================================================
====================================================================================================================
====================================================================================================================
====================================================================================================================

 Question: Max Power Value

You are given an integer array `arr` of size `n`.

For every adjacent pair of elements in the array, calculate the power value defined as:

[
\text{power value} = arr[i]^{arr[i+1]}
]

Your task is to find and return the maximum power value among all such adjacent pairs.

---

 Input

* An integer array `arr` of length `n` (`n ‚â• 2`)

---

 Output

* Return a `long` value representing the maximum power value obtained from any adjacent pair in the array.

---

 Example 1

Input:

```java
arr = {2, 3, 1}
```

Calculation:

* (2^3 = 8)
* (3^1 = 3)

Output:

```java
8
```

---

 Example 2

Input:

```java
arr = {3, 2, 4}
```

Calculation:

* (3^2 = 9)
* (2^4 = 16)

Output:

```java
16
```

---


SOLUTION:

class Solution {
    public long maxPowerValue(int[] arr) {
        int n = arr.length;
        long maxValue = Long.MIN_VALUE;

        for (int i = 0; i < n - 1; i++) {
            long value = (long) Math.pow(arr[i], arr[i + 1]);

            if (value > maxValue) {
                maxValue = value;
            }
        }

        return maxValue;
    }
}
