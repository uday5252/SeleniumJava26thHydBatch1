import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

class TreeNode
{
	int val;
	TreeNode left;
	TreeNode right;
	
	public TreeNode(int val)
	{
		this.val = val;
	}
	
	public static void levelOrderTraversal(TreeNode root)
	{
		
		ArrayList result = new ArrayList();
		
		Queue<TreeNode> dataQueue = new LinkedList<TreeNode>();
		dataQueue.add(root); // [N(4), N(5), N(6)]
		
//		[1], [2, 4]
		
		while(!dataQueue.isEmpty())
		{
			int queueCount = dataQueue.size();
//			queueCount => 2
			
			ArrayList al = new ArrayList();
			
			for(int i = 0; i < queueCount; i++)
			{
					
					
					TreeNode readData = dataQueue.poll(); //read + removes
					al.add(readData.val); //
					
//					
					
					
					if(readData.left != null)
					{
						dataQueue.add(readData.left);
					}
					if(readData.right != null)
					{
						dataQueue.add(readData.right);
					}
					
					
			}
			result.add(al);
			
		}
		
		System.out.println(result);
		
	}
}

public class Fourth {
	public static void main(String[] args) {
		
		TreeNode rootNode = new TreeNode(1);
		TreeNode leftNode1 = new TreeNode(2);
		TreeNode rightNode1 = new TreeNode(4);
		
		rootNode.left = leftNode1;
		rootNode.right = rightNode1;
		
		TreeNode leftNode2 = new TreeNode(5);
		TreeNode rightNode2 = new TreeNode(6);
		
		leftNode1.left = leftNode2;
		leftNode1.right = rightNode2;
		
		
		TreeNode leftNode3 = new TreeNode(7);
		rightNode1.left = leftNode3;
		
		TreeNode.levelOrderTraversal(rootNode);
	
		
	}
}


======================================
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        

        if(p == null && q == null)
        {
            return true;
        }

        if(p == null || q == null)
        {
            return false;
        }

        if(p.val != q.val)
        {
            return false;
        }

        boolean leftStatus = isSameTree(p.left, q.left);
        boolean rightStatus = isSameTree(p.right, q.right);
        
        return leftStatus && rightStatus;

    //    if(leftStatus == true) && (rightStatus == true)
    //    {
    //         return true; 
    //    }
    //    else
    //    {
    //     return false;
    //    }
    }
}
====================
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public TreeNode invertTree(TreeNode root) {

        if(root == null)
        {
            return null;
        }
      
      TreeNode temp = root.left;
      root.left = root.right;
      root.right = temp;

      invertTree(root.left);
      invertTree(root.right);
    //   invertTree(30);
    return root;

    }
}
===========================
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

import java.util.*;

public class Codec {

    public String serialize(TreeNode root)
    {

    if(root == null)
    {
        return "";   
    }

        StringBuilder sb = new StringBuilder(""); //"10"
        Queue<TreeNode> dataQueue = new LinkedList<TreeNode>();

        dataQueue.add(root);

        while(!dataQueue.isEmpty())
        {
            int count = dataQueue.size();
            // for(int i = 0; i < count; i++)
            // {
                
                 TreeNode readNode = dataQueue.poll();
                  if(readNode == null)
                 {
                    sb.append("null,");
                 }
                 else
                 {
                     sb.append(readNode.val);
                     sb.append(",");
                 
                 
                if(readNode.left != null)
            {
                 dataQueue.add(readNode.left);
            }
            else
            {
                dataQueue.add(null);
                // sb.append("null, ");
            }
           
            if(readNode.right != null)
            {
                dataQueue.add(readNode.right);

            }
             else
            {
                dataQueue.add(null);
                // sb.append("null, ");
            }
            
                 }
            
        // }
       
     }
 System.out.println(sb.toString());
        
        return "hello";
    }


    public TreeNode deserialize(String data)
    {

       return new TreeNode();
     
    }
    
    
}

