
## ğŸ§© Problem: Find Missing Words

You are given **two sentences**:

1. **`full` sentence**
   â†’ This is the original sentence.
   â†’ It contains **all words** in correct order.

2. **`partial` sentence**
   â†’ This sentence is created by **removing some words** from the `full` sentence.
   â†’ **Order of remaining words is the same** as in `full`.

---

## ğŸ¯ Your Task

Find **which words are missing** from `partial` when compared to `full`.

ğŸ‘‰ Return **only the missing words**,
ğŸ‘‰ Keep them in the **same order** as they appear in `full`.

---

## âš ï¸ Important Rules

1. **Case does NOT matter**

   * `"Java"` and `"java"` are the same

2. **Ignore punctuation**

   * Commas, dots, exclamation marks, etc. should be ignored

3. **Order matters**

   * `partial` is always a **subsequence** of `full`
   * Words appear in the same order, just with some missing

---

## ğŸ§  Think of it Like This

Imagine:

* `full` = **complete story**
* `partial` = **story with some words erased**

You must **tell which words were erased**.

---

## ğŸ“˜ Simple Example

```
full    = "I love programming very much"
partial = "I programming"
```

### Step-by-step thinking:

* `"I"` â†’ present âœ”
* `"love"` â†’ missing âŒ
* `"programming"` â†’ present âœ”
* `"very"` â†’ missing âŒ
* `"much"` â†’ missing âŒ

### âœ… Output:

```
["love", "very", "much"]
```

---

## ğŸªœ Another Example

```
full    = "Java is very powerful language"
partial = "java powerful"
```

### What happened?

* `"Java"` â†’ present
* `"is"` â†’ missing
* `"very"` â†’ missing
* `"powerful"` â†’ present
* `"language"` â†’ missing

### âœ… Output:

```
["is", "very", "language"]
```

---


SOLUTION 

import java.util.*;

class Solution {
    public List<String> findMissingWords(String full, String partial) {

        // 1. Normalize input (lowercase + remove punctuation)
        full = full.toLowerCase().replaceAll("[^a-z0-9 ]", "");
        partial = partial.toLowerCase().replaceAll("[^a-z0-9 ]", "");

        // 2. Split sentences into words
        String[] fullWords = full.split("\\s+");
        String[] partialWords = partial.split("\\s+");

        // 3. Result list
        List<String> missing = new ArrayList<>();

        // 4. Two pointers
        int i = 0; // pointer for fullWords
        int j = 0; // pointer for partialWords

        // 5. Compare words in order
        while (i < fullWords.length && j < partialWords.length) {

            if (fullWords[i].equals(partialWords[j])) {
                // word found in partial â†’ move partial pointer
                j++;
            } else {
                // word missing â†’ add to result
                missing.add(fullWords[i]);
            }

            // always move full pointer
            i++;
        }

        // 6. Add remaining words (if partial finished early)
        while (i < fullWords.length) {
            missing.add(fullWords[i]);
            i++;
        }

        return missing;
    }
}
====================================================

## ğŸ§© Problem: Caesar Cipher â€“ Decode a String

You are given:

1. A **string `s`**
   â†’ It contains letters (uppercase & lowercase) and may also contain spaces or symbols.

2. An **integer `shift`**
   â†’ This tells how many positions each letter was shifted **forward** during encryption.

Your task is to **decode** the string by shifting every letter **backward** by `shift` positions.

---

## ğŸ” What Is Caesar Cipher? (Simple Explanation)

* The English alphabet has **26 letters**
* In Caesar cipher:

  * Each letter is shifted by a fixed number

### Example (shift = 3)

```
A â†’ D
B â†’ E
C â†’ F
```

So decoding means:

```
D â†’ A
E â†’ B
F â†’ C
```

ğŸ‘‰ **Decode = shift backward**

---

## ğŸ¯ Rules You Must Follow

1. **Uppercase stays uppercase**

   * `Aâ€“Z` remains `Aâ€“Z`

2. **Lowercase stays lowercase**

   * `aâ€“z` remains `aâ€“z`

3. **Non-letter characters stay unchanged**

   * spaces, numbers, symbols (`! @ #`) stay same

4. Alphabet wraps around

   * `A` decoded with shift `1` â†’ `Z`
   * `a` decoded with shift `2` â†’ `y`

---

âœ” Output:

```
"Hello"
```

---

### âœ… Test Case 4: Wrap-around case

```
Input:
s = "abc"
shift = 2
```

```
a â†’ y
b â†’ z
c â†’ a
```

âœ” Output:

```
"yza"
```

---

### âœ… Test Case 5: Non-letter characters

```
Input:
s = "Hello, World!"
shift = 3
```


SOLUTION 

class Solution {

    public String caesarDecode(String s, int shift) {
        StringBuilder result = new StringBuilder();

        for (char c : s.toCharArray()) {
            result.append(decodeChar(c, shift));
        }

        return result.toString();
    }

    private char decodeChar(char c, int shift) {

        // Handle uppercase letters
        if (c >= 'A' && c <= 'Z') {
            return (char) ((c - 'A' - shift + 26) % 26 + 'A');
        }

        // Handle lowercase letters
        if (c >= 'a' && c <= 'z') {
            return (char) ((c - 'a' - shift + 26) % 26 + 'a');
        }

        // Non-alphabet characters remain unchanged
        return c;
    }
}

---

## ğŸ”¢ Example We Will Trace

```java
s = "Khoor"
shift = 3
```

Expected output:

```
"Hello"
```

---

## ğŸ§  High-Level Flow

1. `caesarDecode()` loops through **each character**
2. For every character â†’ calls `decodeChar(c, shift)`
3. Decoded character is appended to `StringBuilder`

---

## ğŸªœ Step-by-Step Trace

### Initial State

```
result = ""
```

---

### ğŸ”¹ Iteration 1

```
c = 'K'
```

Inside `decodeChar('K', 3)`:

* `'K'` is uppercase (`Aâ€“Z`)
* ASCII value of `'K'` = 75
* `'A'` = 65

Calculation:

```
('K' - 'A') = 10
10 - 3 = 7
(7 + 26) % 26 = 7
7 + 'A' = 'H'
```

Return:

```
'H'
```

result now:

```
"H"
```

---

### ğŸ”¹ Iteration 2

```
c = 'h'
```

Inside `decodeChar('h', 3)`:

* lowercase letter
* `'h' - 'a' = 7`
* `7 - 3 = 4`
* `(4 + 26) % 26 = 4`
* `4 + 'a' = 'e'`

Return:

```
'e'
```

result:

```
"He"
```

---

### ğŸ”¹ Iteration 3

```
c = 'o'
```

Calculation:

```
'o' - 'a' = 14
14 - 3 = 11
11 + 'a' = 'l'
```

result:

```
"Hel"
```

---

### ğŸ”¹ Iteration 4

```
c = 'o'
```

Same as above â†’ `'l'`

result:

```
"Hell"
```

---

### ğŸ”¹ Iteration 5

```
c = 'r'
```

Calculation:

```
'r' - 'a' = 17
17 - 3 = 14
14 + 'a' = 'o'
```

result:

```
"Hello"
```

---

## âœ… Final Output

```java
"Hello"
```

---

## ğŸ” Wrap-Around Case Trace

### Input

```java
s = "abc"
shift = 2
```

### Trace

| Char | Calculation            | Output |
| ---- | ---------------------- | ------ |
| a    | (0 - 2 + 26) % 26 = 24 | y      |
| b    | (1 - 2 + 26) % 26 = 25 | z      |
| c    | (2 - 2 + 26) % 26 = 0  | a      |

âœ” Output:

```
"yza"
```

---


---

If you want next:

* **Visual alphabet circle**
* **Encode vs Decode trace**
* **Single character deep dive**
* **Common mistakes explanation**

Just tell me ğŸ‘
